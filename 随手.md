# 1.并发IO

1. 单例模式实现，并发操作IO异常

2. 单例模式，并发调用单例模式方法，是否安全

3. IO存在事务吗

  - 解决方案

    - ```
      同步机制（加锁），确保任时刻只有一个线程可以执行I/O操作
      private static Lock lock = new ReentrantLock();
      
      public synchronized void write(..)
      ```

4. 实现并发I/O安全

代码执行顺序，静态变量，静态代码快，代码块，代码块设置默认值

参数 void test（Class<T> class)

泛型

循环依赖

1. @Lazy

# 2.spring boot

## 2.1.自带tomcat

## 2.2.配置文件不打包到jar文件中

# 3.自启动脚本

# 4.开机自启

# 5.大数据

​	

# 6.微服务

# 7.分布式

# 8.消息队列

# 9.数据结构

# 10.数据库

> （mysql、oracle、mongo、redis、clickHouse）

## 10.1.mysql

### 10.1.1.explain

# 11.cas

# 12.架构

## 12.1.分布式

### 12.1.1.Dubbo

> 阿里巴巴开源的一个高性能、轻量级的Java RPC 框架，致力于提供高性能和透明化的 RPC 远程**服务调用方案**，以及 SOA ***\*服务治理方案\****

1. 分布式协调系统（日志复制系统）：paxos算法及其变体的实现，典型的有zookeeper、etcd；

2. 分布式文件系统：HDFS（hadoop）

3. 分布式NoSQL：Redis、Hbase

4. 消息队列：rabbitmq kafka，关注消息的at least once， at most once， only once。

5. 分布式任务调度：azkaban

6. 分布式计算框架：

7. 基于有限数据集：基于mapreduce的hadoop，基于内存计算的spark

8. 面向无限数据集的流计算：storm，Flink
   -----------------------------------

9. ©著作权归作者所有：来自51CTO博客作者bandaoyu的原创作品，请联系作者获取转载授权，否则将追究法律责任
   【分布式】常见分布式框架
   https://blog.51cto.com/liangchaoxi/4052121

## 12.2.SOA架构

12.3.微服务架构

# 13.并发编程

## 13.1.线程池

### 13.1.1.线程数量定义

#### 13.1.1.1.I/O密集型任务线程池

1.  理论基础

   I/O密集型任务的线程数量通常可以通过以下公式来计算：

   N(thread) = N(cpu) * (1 + W/C)

   其中：

   - N(thread) 是线程池中的线程数。
   - N(cpu) 是可用的CPU核心数。
   - W 是任务的等待时间（I/O时间）。
   - C 是任务的计算时间（CPU时间）。

2.  具体设置

#### 13.1.1.2.CPU密集型任务线程池





## 13.1.2.注

### 13.1.2.1.一个项目创建多个线程池和单个线程池的区别

#### 13.1.2.1.资源管理和隔离

1. 多个线程池
   - 资源隔离：不同任务可以分配到不同的线程池，互不影响。例如，I/O密集型任务和CPU密集型任务可以分配到不同的线程池，避免资源争用。
   - 优先级和策略独立：每个线程池可以配置不同的线程数量、队列大小和拒绝策略，根据任务的特点进行优化。
   - 错误隔离：如果一个线程池中的任务出现问题，不会影响其他线程池中的任务。
2. 单个线程池
   - 资源共享：所有任务共享同一个线程池，容易出现资源争用的情况，特别是在任务类型多样的情况下。
   - 简单管理：只有一个线程池，管理和监控相对简单，但灵活性较低。

#### 13.1.2.2.性能和扩展性

1. 多个线程池
   - 更好的性能：通过将不同类型的任务分配到不同的线程池，可以更好地利用系统资源，避免某类任务拖慢整个系统。
   - 可扩展性：更容易扩展和调整，例如可以动态增加新的线程池来处理新增的任务类型。
2. 单个线程池
   - 简单实现：适合任务类型单一、数量不多的场景，容易实现和管理。
   - 可能的瓶颈：在任务数量增加或任务类型变复杂时，单个线程池可能成为瓶颈，影响系统性能。
3. 代码复杂度
   - 多个线程池
     - 代码复杂度增加：需要管理多个线程池，配置和监控变得复杂
     - 灵活性提高：可以针对不同任务进行优化配置，但需要更多的设计和实现工作。
   - 单个线程池
     - 代码简单：管理一个线程池，代码逻辑简单，适合简单场景。
     - 灵活性降低：不适合复杂的任务场景，难以进行细粒度的优化。
4. 应用场景
   - 多个线程池
     - 适用于复杂的大型应用，任务类型多样，且需要高性能和高可用性。
     - 例如，Web服务器、微服务架构中的服务处理不同类型的请求。
   - 单个线程池
     - 适用于简单的小型应用，任务类型单一，资源需求较低。
     - 例如，简单的批处理任务或单一功能的工具类程序。











​	